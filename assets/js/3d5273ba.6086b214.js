"use strict";(self.webpackChunkcs_1101_teach=self.webpackChunkcs_1101_teach||[]).push([[929],{9613:(n,e,t)=>{t.d(e,{Zo:()=>l,kt:()=>d});var a=t(9496);function r(n,e,t){return e in n?Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):n[e]=t,n}function i(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(n);e&&(a=a.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.push.apply(t,a)}return t}function o(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?i(Object(t),!0).forEach((function(e){r(n,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}))}return n}function s(n,e){if(null==n)return{};var t,a,r=function(n,e){if(null==n)return{};var t,a,r={},i=Object.keys(n);for(a=0;a<i.length;a++)t=i[a],e.indexOf(t)>=0||(r[t]=n[t]);return r}(n,e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(n);for(a=0;a<i.length;a++)t=i[a],e.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(n,t)&&(r[t]=n[t])}return r}var c=a.createContext({}),p=function(n){var e=a.useContext(c),t=e;return n&&(t="function"==typeof n?n(e):o(o({},e),n)),t},l=function(n){var e=p(n.components);return a.createElement(c.Provider,{value:e},n.children)},u={inlineCode:"code",wrapper:function(n){var e=n.children;return a.createElement(a.Fragment,{},e)}},m=a.forwardRef((function(n,e){var t=n.components,r=n.mdxType,i=n.originalType,c=n.parentName,l=s(n,["components","mdxType","originalType","parentName"]),m=p(t),d=r,h=m["".concat(c,".").concat(d)]||m[d]||u[d]||i;return t?a.createElement(h,o(o({ref:e},l),{},{components:t})):a.createElement(h,o({ref:e},l))}));function d(n,e){var t=arguments,r=e&&e.mdxType;if("string"==typeof n||r){var i=t.length,o=new Array(i);o[0]=m;var s={};for(var c in e)hasOwnProperty.call(e,c)&&(s[c]=e[c]);s.originalType=n,s.mdxType="string"==typeof n?n:r,o[1]=s;for(var p=2;p<i;p++)o[p]=t[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},1026:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>c,contentTitle:()=>o,default:()=>u,frontMatter:()=>i,metadata:()=>s,toc:()=>p});var a=t(2081),r=(t(9496),t(9613));const i={id:"studio-13",title:"Studio 13 (The Final Studio)"},o=void 0,s={unversionedId:"studio-13",id:"studio-13",title:"Studio 13 (The Final Studio)",description:"Extra Questions",source:"@site/docs/week-13.md",sourceDirName:".",slug:"/studio-13",permalink:"/CS1101S-teach/studio-13",draft:!1,editUrl:"https://github.com/shenyih0ng/CS1101S-teach/tree/main/docs/week-13.md",tags:[],version:"current",frontMatter:{id:"studio-13",title:"Studio 13 (The Final Studio)"},sidebar:"tutorialSidebar",previous:{title:"Studio 12",permalink:"/CS1101S-teach/studio-12"}},c={},p=[{value:"Extra Questions",id:"extra-questions",level:2},{value:"Q1: <code>n_bonacci(n)</code>",id:"q1-n_bonaccin",level:3},{value:"Q2: <code>find_num_paths(checkpoints)</code>",id:"q2-find_num_pathscheckpoints",level:3},{value:"Part 1",id:"part-1",level:4},{value:"Part 2",id:"part-2",level:4}],l={toc:p};function u(n){let{components:e,...t}=n;return(0,r.kt)("wrapper",(0,a.Z)({},l,t,{components:e,mdxType:"MDXLayout"}),(0,r.kt)("h2",{id:"extra-questions"},"Extra Questions"),(0,r.kt)("h3",{id:"q1-n_bonaccin"},"Q1: ",(0,r.kt)("inlineCode",{parentName:"h3"},"n_bonacci(n)")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Adapted from my tutor back in AY21/22, Zhi Hao :)")),(0,r.kt)("p",null,"We've mentioned the ",(0,r.kt)("inlineCode",{parentName:"p"},"fib")," function countless times throughout these 12 weeks. Be it recursive or iterative, you guys can implement it. Therefore, let's take it up a notch!"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Implement the ",(0,r.kt)("inlineCode",{parentName:"strong"},"n_bonacci(n)")," function such that ",(0,r.kt)("inlineCode",{parentName:"strong"},"n_bonacci(2)")," returns the fibonacci stream and ",(0,r.kt)("inlineCode",{parentName:"strong"},"n_bonacci(3)")," returns a tribonacci stream and so on. You can assume that all inputs will be ",(0,r.kt)("inlineCode",{parentName:"strong"},">=2"),".")),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},(0,r.kt)("strong",{parentName:"p"},"Fibonacci Sequence:")," ",(0,r.kt)("inlineCode",{parentName:"p"},"n = 2")),(0,r.kt)("p",{parentName:"admonition"},(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("inlineCode",{parentName:"strong"},"0 1 1 2 3 5 8 13"))),(0,r.kt)("p",{parentName:"admonition"},(0,r.kt)("strong",{parentName:"p"},"Tribonacci Sequence:")," ",(0,r.kt)("inlineCode",{parentName:"p"},"n = 3")),(0,r.kt)("p",{parentName:"admonition"},(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("inlineCode",{parentName:"strong"},"0 1 1 2 4 7 13 24"))),(0,r.kt)("p",{parentName:"admonition"},(0,r.kt)("strong",{parentName:"p"},"Fourbonacci Sequence:")," ",(0,r.kt)("inlineCode",{parentName:"p"},"n = 4")),(0,r.kt)("p",{parentName:"admonition"},(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("inlineCode",{parentName:"strong"},"0 1 1 2 4 8 15 29")))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"/**\n * You can also consider implementing a `n_bonacci(n, k)` first to get a feel of how it works!\n * `n_bonacci(n, k)` gives you the kth element of a n_bonacci sequence\n **/\nfunction n_bonacci(n) {\n  // TBI\n}\n\neval_stream(n_bonacci(2), 5); // first 5 terms of the fibonacci series\neval_stream(n_bonacci(3), 10); // first 10 terms of the tribonacci series\n")),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"Are you able to make use of ",(0,r.kt)("inlineCode",{parentName:"p"},"n_bonacci(n-1)"),"?")),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("b",null,"Answers")),(0,r.kt)("p",null,"We can actually make use of ",(0,r.kt)("strong",{parentName:"p"},"stream formulation")," to create a ",(0,r.kt)("inlineCode",{parentName:"p"},"n_bonacci")," stream. The intuition lies in how we can make use of a ",(0,r.kt)("inlineCode",{parentName:"p"},"n_bonacci(n-1)")," stream to form a ",(0,r.kt)("inlineCode",{parentName:"p"},"n_bonacci(n)")," stream."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"The first ",(0,r.kt)("inlineCode",{parentName:"strong"},"n")," number of a ",(0,r.kt)("inlineCode",{parentName:"strong"},"n_bonacci(n)")," stream can always be found in the ",(0,r.kt)("inlineCode",{parentName:"strong"},"n_bonacci(n-1)")," stream.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"function add_streams(s1, s2) {\n  return is_null(s1)\n    ? s2\n    : is_null(s2)\n    ? s1\n    : pair(head(s1) + head(s2), () =>\n        add_streams(stream_tail(s1), stream_tail(s2))\n      );\n}\n\nfunction add_n_streams(streams) {\n  return accumulate((curr, acc) => add_streams(acc, curr), null, streams);\n}\n\nfunction take_n_and_replace(stream, n, replace_stream) {\n  return n <= 1\n    ? pair(head(stream), replace_stream)\n    : pair(head(stream), () =>\n        take_n_and_replace(stream_tail(stream), n - 1, replace_stream)\n      );\n}\n\nconst fibonacci_stream = pair(0, () =>\n  pair(1, () => add_streams(fibonacci_stream, stream_tail(fibonacci_stream)))\n);\n\nfunction n_bonacci(n) {\n  function helper(stream, count) {\n    return count <= 1\n      ? pair(stream, null)\n      : pair(stream, helper(stream_tail(stream), count - 1));\n  }\n\n  if (n === 2) {\n    return fibonacci_stream;\n  } else {\n    const n_minus_one_bonacci = n_bonacci(n - 1);\n    const start = take_n_and_replace(n_minus_one_bonacci, n, () =>\n      add_n_streams(helper(start, n))\n    );\n    return start;\n  }\n}\n"))),(0,r.kt)("h3",{id:"q2-find_num_pathscheckpoints"},"Q2: ",(0,r.kt)("inlineCode",{parentName:"h3"},"find_num_paths(checkpoints)")),(0,r.kt)("p",null,"Every point on a grid has a ",(0,r.kt)("inlineCode",{parentName:"p"},"X-Y")," coordinate, which we will represent as a ",(0,r.kt)("inlineCode",{parentName:"p"},"pair"),". Being a CS student, you will like to know how many possible paths there are from a chosen point to another. However, equipped with the knowledge in CS1101S, you think that is too simple of a problem, therefore you will also like to find out how many possible paths there are to get from one point to another, while clearing a ",(0,r.kt)("strong",{parentName:"p"},"set of checkpoints")," in between."),(0,r.kt)("h4",{id:"part-1"},"Part 1"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Implement the ",(0,r.kt)("inlineCode",{parentName:"strong"},"find_num_paths(checkpoints)")," functions such that it returns the total number of possible ways to get from the first to the last checkpoint while also visiting the checkpoints in between. To make things simpler, you will assume that the only valid moves are \u27a1\ufe0f (East) and \u2b06\ufe0f (North).")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"function find_num_paths(checkpoints) {\n  // TBI\n}\n\nconst checkpoints_1 = list(pair(0, 0), pair(4, 6));\nfind_num_paths(checkpoints_1); // 210\n\nconst checkpoints_2 = list(pair(0, 0), pair(2, 3), pair(4, 6));\nfind_num_paths(checkpoints_2); // 100\n")),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("b",null,"Answers")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"function find_num_paths_helper(x, y) {\n  if (x === 0 || y === 0) {\n    return 1;\n  } else {\n    return find_num_paths_helper(x - 1, y) + find_num_paths_helper(x, y - 1);\n  }\n}\n\nfunction find_num_paths(checkpoints) {\n  if (is_null(tail(checkpoints))) {\n    return 1;\n  } else {\n    const point_A = head(checkpoints);\n    const point_B = head(tail(checkpoints));\n    const normalized = pair(\n      head(point_B) - head(point_A),\n      tail(point_B) - tail(point_A)\n    );\n\n    return (\n      find_num_paths_helper(head(normalized), tail(normalized)) *\n      find_num_paths(tail(checkpoints))\n    );\n  }\n}\n"))),(0,r.kt)("h4",{id:"part-2"},"Part 2"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Can we memoize ",(0,r.kt)("inlineCode",{parentName:"strong"},"find_num_paths"),"? If no, why? If yes, why?")),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("b",null,"Answers")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"const mem = [];\n\nfunction read(n, k) {\n  return mem[n] === undefined ? undefined : mem[n][k];\n}\n\nfunction write(n, k, value) {\n  if (mem[n] === undefined) {\n    mem[n] = [];\n  }\n  mem[n][k] = value;\n}\n\nfunction find_num_paths_helper(x, y) {\n  if (x === 0 || y === 0) {\n    return 1;\n  } else if (!is_undefined(read(x, y))) {\n    return read(x, y);\n  } else {\n    const result =\n      find_num_paths_helper(x - 1, y) + find_num_paths_helper(x, y - 1);\n    write(x, y, result);\n\n    return result;\n  }\n}\n\nfunction find_num_paths(checkpoints) {\n  if (is_null(tail(checkpoints))) {\n    return 1;\n  } else {\n    const point_A = head(checkpoints);\n    const point_B = head(tail(checkpoints));\n    const normalized = pair(\n      head(point_B) - head(point_A),\n      tail(point_B) - tail(point_A)\n    );\n\n    return (\n      find_num_paths_helper(head(normalized), tail(normalized)) *\n      find_num_paths(tail(checkpoints))\n    );\n  }\n}\n"))))}u.isMDXComponent=!0}}]);