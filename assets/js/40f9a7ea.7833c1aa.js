"use strict";(self.webpackChunkcs_1101_teach=self.webpackChunkcs_1101_teach||[]).push([[301],{9613:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>m});var o=n(9496);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,o,i=function(e,t){if(null==e)return{};var n,o,i={},a=Object.keys(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var r=o.createContext({}),u=function(e){var t=o.useContext(r),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},p=function(e){var t=u(e.components);return o.createElement(r.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},h=o.forwardRef((function(e,t){var n=e.components,i=e.mdxType,a=e.originalType,r=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),h=u(n),m=i,d=h["".concat(r,".").concat(m)]||h[m]||c[m]||a;return n?o.createElement(d,s(s({ref:t},p),{},{components:n})):o.createElement(d,s({ref:t},p))}));function m(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var a=n.length,s=new Array(a);s[0]=h;var l={};for(var r in t)hasOwnProperty.call(t,r)&&(l[r]=t[r]);l.originalType=e,l.mdxType="string"==typeof e?e:i,s[1]=l;for(var u=2;u<a;u++)s[u]=n[u];return o.createElement.apply(null,s)}return o.createElement.apply(null,n)}h.displayName="MDXCreateElement"},2005:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>r,contentTitle:()=>s,default:()=>c,frontMatter:()=>a,metadata:()=>l,toc:()=>u});var o=n(2081),i=(n(9496),n(9613));const a={id:"studio-6",title:"Studio 6"},s=void 0,l={unversionedId:"studio-6",id:"studio-6",title:"Studio 6",description:"Link to the slides//docs.google.com/presentation/d/1oob7MJssTDE_PzuxgaDp31CBEf3E7fP437JvNhm31fQ/edit?usp=sharing",source:"@site/docs/week-6.md",sourceDirName:".",slug:"/studio-6",permalink:"/CS1101S-teach/studio-6",draft:!1,editUrl:"https://github.com/shenyih0ng/CS1101S-teach/tree/main/docs/week-6.md",tags:[],version:"current",frontMatter:{id:"studio-6",title:"Studio 6"},sidebar:"tutorialSidebar",previous:{title:"Studio 5",permalink:"/CS1101S-teach/studio-5"},next:{title:"Studio 7",permalink:"/CS1101S-teach/studio-7"}},r={},u=[{value:"Studio Worksheets",id:"studio-worksheets",level:2},{value:"Subsets and Permutations",id:"subsets-and-permutations",level:2},{value:"<code>subsets(lst)</code>",id:"subsetslst",level:3},{value:"Function Signature",id:"function-signature",level:4},{value:"Implementation",id:"implementation",level:4},{value:"<code>permutations(lst)</code>",id:"permutationslst",level:3},{value:"Function Signature",id:"function-signature-1",level:4},{value:"Implementation",id:"implementation-1",level:4}],p={toc:u};function c(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,o.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("iframe",{src:"https://docs.google.com/presentation/d/e/2PACX-1vRTGTcc5i0Gc-tqyGkrtMPQBBNE1_ODSJ0qzn0CejXNq0di18Pv_3cTol2QmaRNQj6dZmxd71COZiDv/embed?start=false&loop=false&delayms=3000",frameborder:"0",width:"100%",height:"569",allowfullscreen:"true",mozallowfullscreen:"true",webkitallowfullscreen:"true"}),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Link to the slides: ",(0,i.kt)("a",{parentName:"p",href:"https://docs.google.com/presentation/d/1oob7MJssTDE_PzuxgaDp31CBEf3E7fP437JvNhm31fQ/edit?usp=sharing"},"https://docs.google.com/presentation/d/1oob7MJssTDE_PzuxgaDp31CBEf3E7fP437JvNhm31fQ/edit?usp=sharing"))),(0,i.kt)("h2",{id:"studio-worksheets"},"Studio Worksheets"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("a",{parentName:"li",href:"https://drive.google.com/drive/folders/1Jv_5qs9Ivb_pDDoUSg73dvR_NsNxwNIC?usp=sharing"},"Studio 6 In-class Worksheet"))),(0,i.kt)("h2",{id:"subsets-and-permutations"},"Subsets and Permutations"),(0,i.kt)("p",null,"These are some of the harder functions/questions that you will come across in CS1101S. Take some time to understand the intuition behind the solutions and hopefully after that you will be able to better appreciate the magic and power of recursion \ud83d\ude04"),(0,i.kt)("admonition",{type:"caution"},(0,i.kt)("p",{parentName:"admonition"},(0,i.kt)("strong",{parentName:"p"},"The full solution can be found ",(0,i.kt)("a",{parentName:"strong",href:"https://drive.google.com/file/d/1ZwWCSfYu1fV9QdagkTO9rzf1oLFulV90/view?usp=sharing"},"here"),".")),(0,i.kt)("blockquote",{parentName:"admonition"},(0,i.kt)("p",{parentName:"blockquote"},"The solutions are only accesible by those in my studio, this is so that solutions will not be leaked to future batches")),(0,i.kt)("p",{parentName:"admonition"},"The explanations below are purely the intuitions behind solving these questions, not answers. ")),(0,i.kt)("h3",{id:"subsetslst"},(0,i.kt)("inlineCode",{parentName:"h3"},"subsets(lst)")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"The logic and intuition behind ",(0,i.kt)("inlineCode",{parentName:"p"},"subsets")," is entirely the same as the ",(0,i.kt)("inlineCode",{parentName:"p"},"makeup_amount")," function that you have seen in your studio worksheet.")),(0,i.kt)("h4",{id:"function-signature"},"Function Signature"),(0,i.kt)("p",null,"Before we go into the implementation of the function, it is important we understand what should be the function/type signature of the ",(0,i.kt)("inlineCode",{parentName:"p"},"subsets")," function. ",(0,i.kt)("strong",{parentName:"p"},"If the goal is to get all possible subsets of a given list of values"),", then it is only natural that the function returns a ",(0,i.kt)("strong",{parentName:"p"},"collection of subsets"),"."),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"What better way to store a ",(0,i.kt)("strong",{parentName:"em"},"collection")," of values than a ",(0,i.kt)("inlineCode",{parentName:"em"},"list"),"!")),(0,i.kt)("p",null,"But what should we use to store each individual subset? A subset is a collection of values too, just that the values contained in it are the elements in the given list of values. Then naturally, a ",(0,i.kt)("inlineCode",{parentName:"p"},"list")," would be chosen again to store/represent a single subset."),(0,i.kt)("p",null,"Piecing all that together, we would expect the function/type signature of ",(0,i.kt)("inlineCode",{parentName:"p"},"subsets")," to be:"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("inlineCode",{parentName:"strong"},"List<Number> -> List<List<Number>>"))),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Let's assume all items are of ",(0,i.kt)("inlineCode",{parentName:"p"},"Number")," type")),(0,i.kt)("p",null,"The function signature, althought trivial to some, is a important because it helps us acertain what we will be getting from a recursive call to the ",(0,i.kt)("inlineCode",{parentName:"p"},"subsets")," in our implementation. This also then gives us a hint as to how we can work with the return result of a recursive call and subsequently build on top of it to get our desired result!"),(0,i.kt)("h4",{id:"implementation"},"Implementation"),(0,i.kt)("p",null,"After figuring out the function signature, we will need to understand what is exactly a subset? "),(0,i.kt)("p",null,"To put it simply, it is just a smaller (not strictly though) collection/set of values that are picked from original/initial collection of values. ",(0,i.kt)("strong",{parentName:"p"},"Thus, to get all possible subsets is then a process of generating all possible collection/set of values that can be picked from the original/initial collection of values.")),(0,i.kt)("p",null,"Think about how you would manually write out all the subsets of a set of values. First you would probably write out the entire collection (since it is still a subset), ",(0,i.kt)("strong",{parentName:"p"},"then you will slowly take a item out"),". Then with some patience and hardwork, you eventually get all the subsets."),(0,i.kt)("p",null,"Translating that to a computational process, we are essentially making a choice for each item in the list:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Put this item in the current subset"),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"Do not")," put this item in the current subset",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("em",{parentName:"li"},"This sort of represents the action where you slowly take a item out of a larger subset"))))),(0,i.kt)("p",null,"And that's it \ud83c\udf89 This is the entire intuition behind the function ",(0,i.kt)("inlineCode",{parentName:"p"},"subset"),"."),(0,i.kt)("p",null,"But one last thing to note, what are the possible subsets of a empty set/collection? ",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("inlineCode",{parentName:"strong"},"null")," of course!")," This also makes ",(0,i.kt)("inlineCode",{parentName:"p"},"null")," a valid subset for all collection of values."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"This is the base case you will need to handle!")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"// List<Number> -> List<List<Number>>\nfunction subsets(lst) {\n    if (<base-case>) {\n        // note that your return type should be of type List<List<Number>>\n        return ...\n    } else {\n        // how can i make use of wishful thinking here?\n        const all_possible_subsets_without_current_item_of_lst = ...;\n        // can i make use of ^\n        const all_possible_subsets_with_current_item_of_lst = ...;\n\n        return <all-possible-subsets-for-lst>;\n    }\n}\n")),(0,i.kt)("h3",{id:"permutationslst"},(0,i.kt)("inlineCode",{parentName:"h3"},"permutations(lst)")),(0,i.kt)("p",null,"The intuition and logic behind ",(0,i.kt)("inlineCode",{parentName:"p"},"permutations")," is sadly not exactly the same as ",(0,i.kt)("inlineCode",{parentName:"p"},"subsets")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"makeup_amount"),". This is because it no longer involves making the choice of taking or not taking a element in a given list of values."),(0,i.kt)("h4",{id:"function-signature-1"},"Function Signature"),(0,i.kt)("p",null,"Similar to ",(0,i.kt)("inlineCode",{parentName:"p"},"subsets"),", what we wish to get from the function ",(0,i.kt)("inlineCode",{parentName:"p"},"permutations")," is a collection of all permutations of a given list of values. For the same reasons as above, when we want a collection of anything, a ",(0,i.kt)("inlineCode",{parentName:"p"},"list")," is a good choice!"),(0,i.kt)("p",null,"But what can we use to store a permutation? A permutation is a still a collection of a values, so naturally we will once again choose a ",(0,i.kt)("inlineCode",{parentName:"p"},"list")," to represent it!"),(0,i.kt)("p",null,"Therefore, piecing it together, we would expect the function signature to be:"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("inlineCode",{parentName:"strong"},"List<Number> -> List<List<Number>>"))),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Once again, we are assuming all inputs to be of ",(0,i.kt)("inlineCode",{parentName:"p"},"Number")," type")),(0,i.kt)("h4",{id:"implementation-1"},"Implementation"),(0,i.kt)("p",null,"Personally, I think the most important intuition behind the ",(0,i.kt)("inlineCode",{parentName:"p"},"permutations")," function is the fact that you are now dealing with the ",(0,i.kt)("strong",{parentName:"p"},"positions")," in list instead of the elements in it (as we have seen in ",(0,i.kt)("inlineCode",{parentName:"p"},"subsets"),")."),(0,i.kt)("p",null,"This is somewhat to similar to how we calculate the number of permutations of a given list of values. The way we do it usually begins by ascertaining that the first position of the list could have ",(0,i.kt)("inlineCode",{parentName:"p"},"n")," possible values (where ",(0,i.kt)("inlineCode",{parentName:"p"},"n")," is the number of items in the list), then the next position could have ",(0,i.kt)("inlineCode",{parentName:"p"},"n-1")," possible values (because we have already used one item for the first position). We continue the process and eventually we get a formula of ",(0,i.kt)("inlineCode",{parentName:"p"},"n * (n-1) * (n-2) * ... * 1 = n!"),"."),(0,i.kt)("p",null,"Using that as inspiration, when we are trying to build a collection of all possible permutations, we will try to follow a similar process."),(0,i.kt)("p",null,"As we are traversing through the list, we are also traversing through all the ",(0,i.kt)("strong",{parentName:"p"},"positions")," of a list, from index ",(0,i.kt)("inlineCode",{parentName:"p"},"0")," all the way to index ",(0,i.kt)("inlineCode",{parentName:"p"},"n-1"),". Similar to how we calculate the number of permutations, at each position that we traverse through, we need to ask ourselves how many elements and most importantly ",(0,i.kt)("strong",{parentName:"p"},"what are the specific elements that can fill this position"),". "),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"At this point, I hope you will realise that we will need do some sort of removing/filtering of the original list of values to find out what specific elements can fill a particular position (think about why is it ",(0,i.kt)("inlineCode",{parentName:"em"},"n-1")," at the second step of the calculation mentioned above).")),(0,i.kt)("p",null,"If we were to draw parallels to ",(0,i.kt)("inlineCode",{parentName:"p"},"subsets"),", instead of making just 2 choices at every position, we are essentially making ",(0,i.kt)("inlineCode",{parentName:"p"},"n")," choices where ",(0,i.kt)("inlineCode",{parentName:"p"},"n"),' is the length of the list (at the current "step").'),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"function permutations (lst) {\n    if (<base-case>) {\n        // think back to the `subsets`\n        return ...\n    } else {\n        // every element of lst can fill the current position that we at right now\n        // consider how that links up to how we can get all possible permutations for rest of the lst\n        // hint: you should use `remove`/`filter` here\n        const all_permutations_of_length_n_minus_one = ...\n        // how can we make use of ^\n        const all_permutations_of_length_n = ...\n\n        return <all-possible-permutations>;\n    }\n}\n")))}c.isMDXComponent=!0}}]);